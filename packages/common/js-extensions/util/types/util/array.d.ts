import { IRecord, IFunc } from "@codinus/types";
/**
 * Utility namespace for array manipulation functions.
 */
/**
 * Returns a new array with only unique elements from the original array.
 *
 * @template T - The type of elements in the array.
 * @param {Array<T>} array - The array from which to remove duplicate elements.
 * @returns {Array<T>} A new array containing only unique elements from the original array.
 */
export declare function arrayUnique<T>(array: Array<T>): Array<T>;
/**
 * Generates an array of numbers within a specified range.
 *
 * @param start - The starting number of the range (inclusive).
 * @param end - The ending number of the range (inclusive).
 * @returns An array of numbers from start to end, inclusive.
 *
 * @example
 * ```typescript
 * const range = arrayRange(1, 5);
 * console.log(range); // Output: [1, 2, 3, 4, 5]
 * ```
 */
export declare function arrayRange(start: number, end: number): number[];
/**
 * Removes elements from an array based on a predicate function.
 *
 * @template T - The type of elements in the array.
 * @param {Array<T>} source - The array from which to remove elements.
 * @param {(value: T, index: number) => boolean} predicate - The function to test each element.
 * @returns {boolean} True if any elements were removed, otherwise false.
 */
export declare function removeFromArray<T>(source: Array<T>, predicate: (value: T, index: number) => boolean): boolean;
/**
 * Removes the first occurrence of a specific item from an array.
 *
 * @template T - The type of elements in the array.
 * @param {Array<T>} source - The array from which to remove the item.
 * @param {T} item - The item to remove.
 * @returns {number} The index of the removed item, or -1 if the item was not found.
 */
export declare function removeFromArray<T>(source: Array<T>, item: T): number;
/**
 * Adds items to the source array based on a condition.
 *
 * @template T - The type of elements in the array.
 * @param {Array<T>} source - The source array to which items will be added.
 * @param {...[value: T, condition?: boolean][]} items - The items to be added, each item is a tuple where the first element is the value to add and the second element is an optional condition.
 * @returns {Array<T>} The updated source array.
 *
 * @example
 * const source = [1, 2, 3];
 * addToArray(source, [4, true], [5, false], [6]);
 * // source is now [1, 2, 3, 4, 6]
 */
export declare function addToArray<T>(source: Array<T>, ...items: [value: T, condition?: boolean][]): Array<T>;
/**
 * Populates an array with the provided items based on their conditions.
 *
 * @template T - The type of the items in the array.
 * @param {...[value: T, condition?: boolean][]} items - The items to populate the array with. Each item is a tuple where the first element is the value and the second element is an optional condition. If the condition is `false`, the item will be excluded from the resulting array.
 * @returns {T[]} An array containing the values of the items that meet the condition.
 */
export declare function arrayPopulate<T>(...items: [value: T, condition?: boolean][]): T[];
/**
 * Converts an array or readonly array into a Map.
 *
 * @template TItem - The type of the items in the array.
 * @template TKey - The type of the keys in the resulting Map. Defaults to string.
 * @template TValue - The type of the values in the resulting Map. Defaults to TItem.
 *
 * @param {Array<TItem> | ReadonlyArray<TItem>} array - The array to convert into a Map.
 * @param {IFunc<TItem, TKey>} keySelector - A function that extracts the key for each item in the array.
 * @param {IFunc<TItem, TValue>} [valueSelector] - An optional function that extracts the value for each item in the array. If not provided, the item itself is used as the value.
 *
 * @returns {Map<TKey, TValue>} A Map where the keys are generated by the keyGetter function and the values are generated by the valueGetter function.
 */
export declare function arrayToMap<TItem, TKey = string, TValue = TItem>(array: Array<TItem> | ReadonlyArray<TItem>, keySelector: (item: TItem, index: number) => TKey, valueSelector?: (item: TItem, index: number) => TValue): Map<TKey, TValue>;
/**
 * Converts a Map to an array using an optional getter function.
 *
 * @template TItem - The type of the items in the resulting array.
 * @template TValue - The type of the values in the map.
 * @template TKey - The type of the keys in the map. Defaults to string.
 *
 * @param {Map<TKey, TValue>} map - The map to convert to an array.
 * @param {(key: TKey, value: TValue) => TItem} [transform] - An optional function to transform each key-value pair into an item for the array.
 * @returns {Array<TItem>} An array containing the items generated from the map.
 */
export declare function arrayFromMap<TItem, TValue, TKey = string>(map: Map<TKey, TValue>, transform?: (key: TKey, value: TValue) => TItem): Array<TItem>;
/**
 * Converts an object to an array using an optional getter function.
 *
 * @template TItem - The type of the items in the resulting array.
 * @template TValue - The type of the values in the object.
  *
 * @param {IRecord<TItem>} source - The object to convert to an array.
 * @param {(key: string, value: TItem) => TResult} [transform] - An optional function to transform each key-value pair into an item for the array.
 * @returns {Array<TResult>} An array containing the items generated from the map.
 */
export declare function arrayFromObject<TItem, TResult>(source: IRecord<TItem>, transform?: (key: string, value: TItem) => TResult): Array<TResult>;
/**
 * Returns an array containing the intersection of two arrays.
 * The intersection of two arrays is a new array that contains all of the elements that are present in both arrays.
 *
 * @template T - The type of elements in the arrays.
 * @param arr1 - The first array.
 * @param arr2 - The second array.
 * @returns An array containing the elements that are present in both `arr1` and `arr2`.
 *
 * @example
 * ```typescript
 * const array1 = [1, 2, 3, 4];
 * const array2 = [3, 4, 5, 6];
 * const result = arrayIntersection(array1, array2);
 * console.log(result); // Output: [3, 4]
 * ```
 */
export declare function arrayIntersection<T>(arr1: T[], arr2: T[]): T[];
/**
 * Calculates the sum of the elements in an array. Optionally, a transform function can be provided
 * to convert each element to a number before summing.
 *
 * @template T - The type of elements in the array.
 * @param {T[]} array - The array of elements to sum.
 * @param {IFunc<T, number>} [transform] - An optional transform function to convert each element to a number.
 * @returns {number} The sum of the elements in the array.
 */
export declare function arraySum<T>(array: T[], transform?: IFunc<T, number>): number;
/**
 * Calculates the average of the elements in an array.
 *
 * @template T - The type of elements in the array.
 * @param {T[]} array - The array of elements to calculate the average from.
 * @param {IFunc<T, number>} [transform] - An optional transform function to apply to each element before averaging.
 * @returns {number} The average of the elements in the array. Returns 0 if the array is empty or not an array.
 */
export declare function arrayAvg<T>(array: T[], transform?: IFunc<T, number>): number;
/**
 * Sorts an array based on a transformation function and direction.
 *
 * @template T - The type of elements in the array.
 * @param {T[]} array - The array to be sorted.
 * @param {IFunc<T, unknown>} [transform] - An optional transformation function to apply to each element before sorting.
 * @param {1 | -1} [direction=1] - The direction of the sort: 1 for ascending, -1 for descending.
 * @param {string} [locale] - An optional locale string to use for locale-sensitive string comparisons.
 * @returns {T[]} - The sorted array.
 */
export declare function arraySort<T>(array: T[], transform?: IFunc<T, unknown> | undefined, direction?: 1 | -1, locale?: string): T[];
/**
 * Converts an array or readonly array into an object using a callback function to generate key-value pairs.
 *
 * @template T - The type of elements in the source array.
 * @template O - The type of values in the resulting object.
 * @param {Array<T> | ReadonlyArray<T>} source - The source array to convert.
 * @param {(value: T, index: number) => [string, O]} callback - A function that takes an element and its index and returns a tuple containing the key and value for the object.
 * @param {boolean} [ignoreNull=false] - Whether to ignore null values in the resulting object.
 * @returns {IRecord<O>} The resulting object with keys and values generated by the callback function.
 */
export declare function arrayToObject<T, O>(source: Array<T> | ReadonlyArray<T>, callback: (value: T, index: number) => [string, O], ignoreNull?: boolean): IRecord<O>;
export declare function arrayGroupBy<T>(source: Array<T>, callback: (value: T, index: number) => string): IRecord<T[]>;
/**
 * Adds utility functions as prototype extensions to the Array object.
 * Used to enable Array.prototype methods for convenience.
 */
